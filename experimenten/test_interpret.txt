(last
    # check self referenial loops with (print (last (assign n (1)) (add n (n))))
    
    (assert (assign n 5) 5)
    (assert (eq (add n 1) 6))
    (assert (eq (sub n 1) 4))
    (assert (eq (mul n 2) 10))
    (assert (eq (div n 2) 2))
    (assert (eq (for i n i) (0 1 2 3 4)))
    (assert (eq (for i n (i)) ((0) (1) (2) (3) (4))))
    (assert (eq (assign x (1 2 3 4 5 6 7 8 9 0)) x))
    (assert
        (eq
            (last
                (assign board ((1 2 3) (4 5 6) (7 8 9)))
                (assign row 1)
                (assign n (len board))
                (for col n (at board row col))
            )
            (4 5 6)
        )
    )
    (assert (eq (if 1 23 52) 23))
    (assert (eq (if 0 23 52) 52))
    (assert (eq (if (0) 23 52) 23))
    (assert (eq (if (()) 23 52) 23))
    (assert (eq (if () 23 52) 52))
    (assert (eq (if 1 23) 23))
    (assert (eq (if 0 23) 0))

    # Test 1 scope of variables : functions have only access to their params and local variables
    (assign n 5)
    (function test_scope1 (n)(assign n 0))
    (test_scope1 17)
    (assert (eq n 5))

    # Test 1 scope of variables : functions have only access to their params and local variables
    (assign m 5)
    (function test_scope2 ()(assign m 0))
    (assert (eq (test_scope2) 0))
    (assert (eq m 5))
    (assert (eq (at ((1 2 3) (4 5 6) (7 8 9)) 1) (4 5 6)))

    # Test functions and function calls with 3x3 magix square code
    (function get_row (board row)
        (for col (len board)
            (at board row col)
        )
    )
    (function get_col (board col)
        (for row (len board)
            (at board row col)
        )
    )
    (function get_diag1 (board)
        (for i (len board)
            (at board i i)
        )
    )
    (function get_diag2 (board)
        (last
            (assign n (len board))
            (for i n
                (at board (sub (sub n 1) i) i)
            )
        )
    )
    (assert (eq (sum (1 2 3)) 6))
    (assert (eq (sum (1 2 3 4)) 10))
    (function compute_sums_magic_square (board)
        (extend
            (for row (len board) (sum (get_row board row)))
            (for col (len board) (sum (get_col board col)))
            ((sum (get_diag1 board)))
            ((sum (get_diag2 board)))
        )
    )
    (function is_magic_square (board)
        (last
            (assign n (len board))
            (assign magic_number (div (mul n (add (mul n n) 1)) 2))
            (assign sums (compute_sums_magic_square board))
            (assign ok (for i (len sums) (eq (at sums i) magic_number)))
            (assign count_ok (sum ok))
            (eq count_ok (len sums))
        )
    )
    (assert (eq (get_row ((1 2 3) (4 5 6) (7 8 9)) 1) (4 5 6)))
    (assert (eq (get_col ((1 2 3) (4 5 6) (7 8 9)) 1) (2 5 8)))
    (assert (eq (get_diag1 ((1 2 3) (4 5 6) (7 8 9)) 1) (1 5 9)))
    (assert (eq (get_diag2 ((1 2 3) (4 5 6) (7 8 9)) 1) (7 5 3)))
    (assert (eq (compute_sums_magic_square ((1 2 3) (4 5 6) (7 8 9))) (6 15 24 12 15 18 15 15)))
    (assert (eq (compute_sums_magic_square ((4 9 2) (3 5 7) (8 1 6))) (15 15 15 15 15 15 15 15)))
    (assert (eq (is_magic_square ((1 2 3) (4 5 6) (7 8 9))) 0))
    (assert (eq (is_magic_square ((4 9 2) (3 5 7) (8 1 6))) 1))
    
    (assert (eq (extend (1 2 3) (4 5 6)) (1 2 3 4 5 6)))
    (assign board ((4 9 2) (3 5 7) (8 1 6)))
    (assert (eq (extend
            (for row board (sum row))
            (for col (len board) (sum (get_col board col)))
            ((sum (get_diag1 board)))
            ((sum (get_diag2 board)))
        )
        (15 15 15 15 15 15 15 15))
    )
    (assign x 1)
    (assert (eq (at x x) 0))
    (assign x (1 2))
    (assert (eq (at x x) 0))
    (assign x ((1 2) (3 4)))
    (assert (eq (at x x) 0))
    
    # sort
    (function mysort (data)
        (last
            (for i (len data)
                (for j (sub (len data) (add i 1))
                    (if (gt (at data j) (at data (add j 1)))
                        (assign data
                            (extend
                                (for k j (at data k))
                                    (extend
                                        (list2 (at data (add j 1)) (at data j))
                                        (for k (sub (len data) (add j 2)) (at data (add (add j 2) k)))))))))
                        
            data))
            
    (assign x (0 1 2 2 3 4))
    (assert (eq (mysort x) (0 1 2 2 3 4)))
    (assign y (5 3 2 2 1 0))
    (assert (eq (mysort y) (0 1 2 2 3 5)))
    (function is_sorted1 (data)
        (or 
            (le (len data) 1) 
            (and (le (first data) (first (rest data))) (is_sorted1 (rest data)))))
    (assert (is_sorted1 x))
    (assert (not (is_sorted1 y)))
    (function is_sorted2 (data)
        (not (sum (for i (sub (len data) 1) (gt (at2 data i) (at2 data (add i 1)))))))
    (assert (is_sorted2 x))
    (assert (not (is_sorted2 y)))
    (function is_sorted3 (data)
        (eq (for i (sub (len data) 1) (le (at2 data i) (at2 data (add i 1))))
            (for i (sub (len data) 1) 1)))
    (assert (is_sorted3 x))
    (assert (not (is_sorted3 y)))

    (function mymerge (data1 data2)
        (if_then_else (and data1 data2)
            (if_then_else (lt (first data1) (first data2))
                (extend (list1 (first data1)) (mymerge (rest data1) data2))
                (if_then_else (gt (first data1) (first data2))
                    (extend (list1 (first data2)) (mymerge data1 (rest data2)))
                    (if_then_else (eq (first data1) (first data2))
                        (extend (list2 (first data1 ) (first data2)) (mymerge (rest data1) (rest data2))))))
            (if_then_else data1 data1
                (if_then_else data2 data2
                    ()))))
    (assert (eq (mymerge (mysort x) (mysort y)) (0 0 1 1 2 2 2 2 3 3 4 5)))
)