

for f in po* ; do grep '\#' $f | head -1 | sed 's/.*\# //'; done | sort -n | uniq -c

======== email naar Victor 20 Jan


Analyse suboptima van de 996 runs die van scratch beginnen en zonder oplossing stoppen.
Ze stoppen na 14 iteraties geen verbetering, ze doen geen grote opschudding.
De verschillende suboptima hieronder, de linker kolom is de frequentie.
for f in po* ; do grep '\#' $f | head -1 | sed 's/.*\# //'; done | sort -n | uniq -c
      1 0.600
      1 2.366
      1 2.766
      2 6.610
      1 8.015
      8 9.919
      7 10.719
     11 10.919
     18 11.885
     14 12.085
     50 13.053
    300 15.384
      1 17.800
    581 18.275
Suboptimum met waarde 18.275 komt het meest voor.
grep -h -e 'gen  0 best' lo* | sed 's/sc.*//' | sort | uniq -c
      1 gen  0 best  15.384 
    999 gen  0 best  18.275 
Er zijn 999 runs met een initiele populatie met waarde 18.275, 1 run begint met 15.384.
Die 581 runs beginnen dus in 18.275 en komen nooit verder!


Effect opschudding via her-parachuten op de 18.275 suboptima.
Ik was benieuwd wat het effect was van opschudding via re-entering-parachuting-fase op de 18.275 populaties.
Dat heb ik onderzocht met samenvoegen van 18.275 suboptima.  Samenvoegen van de 581 suboptima met waarde 18.275 geeft:
	1/200=~0.5%.
Voor dit experiment zijn dus 200 runs gedaan, en iedere run had een startpopulatie met 4000/581=6 random
individuals uit ieder van de 581 suboptima.  Conclusie: ontsnappen uit 18.275 via her-parachuten lukt niet.

Ter vergelijking, samenvoegen van alle suboptima gaf:
	47/200=~23.5%
Voor dit experiment zijn 1000 runs gedaan, en iedere run had een startpopulatie met 4000/996=4 random
individuals uit ieder van de 996 suboptima.

Een significant verschil in performance.


Resterende vragen voor vervolganalyses die in me opgekomen zijn: 
- hoeveel families hebben evaluatie 18.275?
		- analyse_best optie in params
- wat doet de meest voorkomende familie? (Alle code snippets in die familie hebben dezelfde output, wat is die output?)
		- snippet uit analyse_best analyseren, sneller is de uitvoer van de snippet ook afdrukken
- welke ontsnappingen zijn er uit 18.275?  Is dat terug te voeren op bepaalde families?
		- daar was een speciaal stukje code voor, 24 dec "follow subopt.py"

=========================== na gesprek met Victor =================================
- acsh 1000 doen = baseline = 7/1000
output in tmp/acshx/analysis.txt
  error family_index individuals shortest_individual                                          last_output                    last_error                    
 18.275            0         515 append(sorted_data, elem)                                    (81, 82, 87, 88, 84)           0.000 0.000 0.000 0.000 14.196
 18.234           18           1 for(i, append(append(sorted_data, elem), if_then_else(sorted (81, 82, 84, 84, 84, (81, 82,  0.143 1.000 0.000 0.000 13.196
 15.384            1         309 append(for(k, sorted_data, assign(elem, k)), assign(k, elem) (81, 82, 87, 88, 88)           0.000 0.000 2.828 0.000 6.196 
 13.053            3          27 append(for(k, sorted_data, assign(sorted_data, k)), if_then_ (81, 82, 87, 88, 88)           0.000 0.000 2.828 0.000 6.196 
 13.053           10           9 last3(for(k, sorted_data, if_then_else(if_then_else(i, le(el (81, 82, 87, 88, 88)           0.000 0.000 2.828 0.000 6.196 
 13.053           11           2 last3(assign(k, if_then_else(sorted_data, i, elem)), for(i,  (81, 82, 87, 88, 88)           0.000 0.000 2.828 0.000 6.196 
 13.053           19           1 append(sorted_data, last3(elem, assign(sorted_data, for(k, s (81, 82, 87, 88, 88)           0.000 0.000 2.828 0.000 6.196 
 12.817            2           9 append(sorted_data, if_then_else(for(elem, sorted_data, appe (81, 82, 87, 88, 88)           0.000 0.000 2.828 0.000 6.196 
 12.519            7           1 append(append(sorted_data, last3(for(k, sorted_data, append( (81, 82, 87, 88, 88, (81, 82,  0.143 1.000 0.000 0.000 6.196 
 12.519           13           2 append(append(for(i, sorted_data, last3(append(k, elem), ass (81, 82, 87, 88, 88, (81, 82,  0.143 1.000 0.000 0.000 6.196 
 12.519           16           1 append(append(for(k, sorted_data, last3(assign(sorted_data,  (81, 82, 87, 88, 88, ((81, 82, 0.143 1.000 0.000 0.000 6.196 
 12.519           20           1 append(append(for(i, sorted_data, assign(elem, last3(assign( (81, 82, 87, 88, 88, (81, 82,  0.143 1.000 0.000 0.000 6.196 
 12.085            6          27 append(last3(assign(i, elem), i, append(for(k, sorted_data,  (81, 82, 87, 88, 88, 84)       0.000 1.000 0.000 0.000 6.196 
 11.885            8          35 append(last3(le(i, k), assign(k, sorted_data), last3(for(i,  (81, 82, 87, 88, 88, 84)       0.000 1.000 0.000 0.000 6.196 
 10.919            9          18 append(append(for(sorted_data, sorted_data, assign(k, sorted (81, 82, 87, 88, 88, 84)       0.000 1.000 0.000 0.000 6.196 
 10.919           12           1 append(append(for(sorted_data, sorted_data, sorted_data), if (81, 82, 87, 88, 88, 84)       0.000 1.000 0.000 0.000 6.196 
 10.719            4          21 if_then_else(for(k, sorted_data, assign(i, if_then_else(le(e (81, 82, 87, 88, 88, 84)       0.000 1.000 0.000 0.000 6.196 
  9.919            5          10 append(if_then_else(if_then_else(for(k, sorted_data, for(ele (81, 82, 87, 88, 88, 84)       0.000 1.000 0.000 0.000 6.196 
  8.532           15           1 append(append(for(sorted_data, for(sorted_data, sorted_data, (81, 82, 84, 88, 88, (81, 82,  0.143 1.000 0.000 0.000 1.000 
  6.610           17           1 append(for(sorted_data, sorted_data, if_then_else(le(assign( (81, 82, 84, 84, 88)           0.000 0.000 1.000 0.000 5.196 
  2.766           14           1 append(for(k, sorted_data, if_then_else(le(elem, k), assign( (81, 82, 84, 88, 88)           0.000 0.000 1.000 0.000 1.000 
                             993                                                                                             0.857 12.000 18.971 0.000 133.
- default gewichten zetten in evaluatie functie op grond van acsh 993 suboptima totale populatie analyse.
0/1000
Maar het is dan ook niet meteen duidelijk hoe dynamic weights moeten werken...
Als in populatie som fout stijgt in een iteratie : gewicht / 1.1;
Als in populatie som fout daalt in een iteratie : gewicht * 1.1;
beginnen met default gewichten terug op 1.0 en dynamische gewichten ook op 1.0.  
- dynamic weights werkend maken
- baseline na dynamic weights weer werkend 7/1000.  Samenvatting aanpassingen tov 4/1000
  - error wegens type iets gedifferentieerd (heeft effect 7/1000)
  - local search : bij gelijke evaluatie is de individual van van de kleinste familie beter (heeft geen effect)
  - stuck detectie : nu alleen op family index van de beste
- dynamic weights met "dempen" van fouten verergeringen : 3/1000
- dynamic weights met "versterken" van fouten verergeringen : 2/1000
- evaluatie verder uitsplisen, zonder dynamic weights
  - 5e dim anders ophouden bij len(expected) : 
  - 6e dimensie hoeveel van de volgorde klopt? : 

